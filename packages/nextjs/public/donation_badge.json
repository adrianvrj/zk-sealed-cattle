{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":1520781604976421896,"abi":{"parameters":[{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"lot_id","type":{"kind":"field"},"visibility":"private"},{"name":"winner","type":{"kind":"field"},"visibility":"private"},{"name":"commitment","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"19":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            //@safety : unconstrained context\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"62":{"source":"// Circuito para probar que el ganador conoce el monto y el secreto de su puja\nuse poseidon::poseidon::bn254::hash_4;\n\nfn main(\n    // PRIVATE INPUTS (solo el ganador las conoce)\n    amount: Field,\n    secret: Field,\n    \n    // PUBLIC INPUTS (visibles en la prueba)\n    lot_id: Field,\n    winner: Field,\n    commitment: pub Field\n) {\n    // Calcular el hash con Poseidon (mismo algoritmo que usar en el frontend)\n    let computed = hash_4([secret, amount, lot_id, winner]);\n    \n    // Verificar que coincide con el commitment almacenado\n    assert(computed == commitment);\n}","path":"/workspaces/starknet-privacy-toolkit/zk-badges/donation_badge/src/main.nr"},"63":{"source":"pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse std::default::Default;\nuse std::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        std::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        std::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    std::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: u32,\n    capacity: u32,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, (rate + capacity) as Field);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n","path":"/home/codespace/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/mod.nr"},"65":{"source":"// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::poseidon::bn254::consts;\nuse crate::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n","path":"/home/codespace/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/bn254/perm.nr"},"66":{"source":"// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n","path":"/home/codespace/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/bn254.nr"}},"names":["main"],"brillig_names":[]}